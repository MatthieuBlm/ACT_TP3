Breuzon Camille
Opsommer Maxime


Q.1)  Ici un certificat serait une rÃ©partition possible des objets dans les diffÃ©rents sacs.
      ImplÃ©mentation possible : k listes d'objets.
      Sa taille serait de n.
      La taille du certificat est bien bornÃ©e polynomialement par rapport au nombre d'entrÃ©e puisque celles-ce sont Ã©gales.
      Algorithme de vÃ©rification :

        Pour chaque liste l {
          int sum = 0;
          Pour chaque objet o de l {
            sum += o.size();
          }
          if(sum > c)
            return false;
        }
        return true;

        Cet algorithme est bien polynomiale.

Q.2.1)  Soit l1 la liste d'objets Ã  ranger
        Soit l2 la liste de sacs

        Pour chaque objet o de l {
          int numSac = getRandomNumber(Entre 0 et l2.size());
          l2.get(numSac).add(o);
        }

        Cette algorithme gÃ©nÃ¨re des certificat uniforme.

Q.2.2)  GÃ©nÃ©rer certificat alÃ©atoire;
        VÃ©rifier le certificat;

Q.3.1)  Avec n fixÃ©, le certificat peut prendre k^n forme.

Q.3.2)  Toutes les possibilités de certificat s'obtiendront en "comptant en base k"

		exemple : (pour n=6 et k=3)
		
		On liste de la manière suivante grâce à un tableau d'entier qui indique que l'objet,
		"indice du tableau" va dans le sac "valeur à cet indice"
		
		[0, 0, 2, 1, 0, 1]  --->  Les objets 0, 1 et 4 vont dans le sac 0
								  Les objets 3 et 5 vont dans le sac 1
								  L'objet 2 va dans le sac 2
								  
		Le certificat suivant serait [0, 0, 2, 1, 0, 2]
		puis						 [0, 0, 2, 1, 1, 0]
									 [0, 0, 2, 1, 1, 1]
									 ..................
									 ..................
									 ..................
		jusqu'à						 [2, 2, 2, 2, 2, 2]

		

Q.3.3)  Pour tester si le problème a une solution, on liste les possiblités comme évoqué à la question précédente,
		jusqu'à trouver un certificat qui vérifie les conditions, s'il existe. (Chaque poids des sacs doit être
		inférieur ou égal à sa capacité). Sinon on renvoie Faux.
		
		Complexité vérifie si certificatCorrect = N
		
		Complexité AUneSolution = Cplx (CertCorrect) * (k^n) = N(K^N)
		
		
Q.5)	Le problème de partition équivaut à un problème de BinPack avec 2 sacs de capacité (somme des xi / 2)

Q.5.2)	Un problème complet est NP-dur, donc NP (NP-dur inclus dans NP)
		Or, si une propriété np-dur se réduit en une autre propriété, elle est elle aussi np dur
		De plus, Partition est np-dur et est réduit en BinPack, donc BinPack est np-dur
		
Q.5.3)	Oui, car partition est np complete
		
Q.6.1)	Partition est un cas particulier de Sum avec C la moitié de la somme des xi.

Q.7)	Soit la liste d'entiers x = {12, 12, 8, 4, 6, 10, 4} et la capacité c = 26

		On a : somme des xi = 56
		
		On veut réduire le problème Sum en problème Partition (donc avec 2 sacs), l'objectif étant qu'au moins un des 2 sacs contient exactement C.
		Or, si l'on veut résoudre le problème en tant que "Partition" (2 parts égales) il faut rajouter un entier "temporaire" à X, de manière à
		ce que la moitié de la somme des xi (avec le nouveau X) vale l'entier cible.
		(somme des xi) / 2 = 28  et  C = 26
		Pour obtenir 26, il faut que la somme des xi vale le double de C, soit 52.
		Si l'on insère -4 à la liste, on obtient bien un C égal à 26.
		
		De manière générale, on a :
		soit Y la valeur que l'on veut insérer
		
		((somme xi) + Y) / 2 = C
		(somme xi) + Y = 2C
		Y = 2C - (somme xi)
		
		
		Cette équation est résolvable si et seulement s'il existe une solution au problème de Partition.
		
Q.8)	On réduit Sum en Partition, puis en BinPack.

Q.9)